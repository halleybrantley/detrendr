# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Discrete derivative matrix
#'
#' \code{get_D1} computes the sparse discrete derivative matrix.
#'
#' @param n length of input
#' @export
#' @importFrom Matrix sparseMatrix
#' 
get_D1 <- function(n) {
    .Call('_detrendr_get_D1', PACKAGE = 'detrendr', n)
}

#' kth order sparse difference matrix
#'
#' \code{get_Dkn} computes the sparse discrete kth derivative matrix
#'
#' @param n length of input
#' @param k order of the derivative
#' @export
get_Dk <- function(n, k) {
    .Call('_detrendr_get_Dk', PACKAGE = 'detrendr', n, k)
}

#' @useDynLib detrendr
#' @importFrom Rcpp evalCpp
NULL

#' Banded Cholesky Solve
#'
#' \code{chol_solve} Solves a linear system cholM%*%x=b
#' when cholM is a sparse banded cholesky.
#'
#' @param cholM sparse banded cholseky decomposition of discrete derivative
#' matrix of order k
#' @param b dense solution vector
#' @param k order of discrete derivative matrix
#' @param upper boolean indicator of whether cholM is upper or lower triangular
#' @export
chol_solve <- function(cholM, b, k, upper = TRUE) {
    .Call('_detrendr_chol_solve', PACKAGE = 'detrendr', cholM, b, k, upper)
}

#' Proximal Mapping
#'
#' \code{prox_quantile} computes the proximal mapping of the check function.
#'
#' @param w input
#' @param tau quantile parameter
#' @param alpha scale parameter
#' @export
prox_quantile <- function(w, tau, alpha) {
    .Call('_detrendr_prox_quantile', PACKAGE = 'detrendr', w, tau, alpha)
}

#' Proximal mapping of f_1
#'
#' \code{prox_f1} computes the proximal mapping of the average quantile loss
#'
#' @param theta input
#' @param y response
#' @param tau quantile parameter
#' @param step step-size
#' @export
prox_f1 <- function(theta, y, tau = 0.05, step = 1.0) {
    .Call('_detrendr_prox_f1', PACKAGE = 'detrendr', theta, y, tau, step)
}

#' Proximal mapping of f_2
#'
#' \code{prox_f2} computes the proximal mapping of the L1 penalty
#'
#' @param eta input
#' @param lambda regularization parameter
#' @param step step-size
#' @examples
#' set.seed(12345)
#' n <- 1e3
#' eta <- seq(-3, 3, length.out=n)
#' lambda <- 1
#' prox_out <- prox_f2(eta, lambda)
#' plot(eta, prox_out, type = 'l')
#' abline(0,1)
#' @export
prox_f2 <- function(eta, lambda, step = 1) {
    .Call('_detrendr_prox_f2', PACKAGE = 'detrendr', eta, lambda, step)
}

#' Proximal mapping
#'
#' \code{prox} computes the block separable proximal mapping, changes theta
#' and eta in place
#'
#' @param theta input
#' @param eta input
#' @param y response
#' @param lambda regularization parameter
#' @param tau quantile parameter
#' @param step step-size
#' @export
prox <- function(theta, eta, y, lambda, tau = 0.05, step = 1.0) {
    invisible(.Call('_detrendr_prox', PACKAGE = 'detrendr', theta, eta, y, lambda, tau, step))
}

#' Project onto subspace
#'
#' \code{project_V} projects (theta, eta) onto the subspace eta = D*theta.
#' Updates values of theta and eta in place.
#'
#' @param theta first input
#' @param eta second input
#' @param D differencing matrix
#' @param cholM upper triangular cholesky decomposition of  I + DtD
#' @param k order of differencing matrix
#' @export
project_V <- function(theta, eta, D, cholM, k) {
    invisible(.Call('_detrendr_project_V', PACKAGE = 'detrendr', theta, eta, D, cholM, k))
}

#'
#' One step of Spingarn's algorithm
#'
#' \code{spingarn_one_step} updates theta and eta in place
#' @param theta input 1
#' @param eta input 2
#' @param y response
#' @param D differencing matrix
#' @param cholM upper cholesky of  (I + DtD)
#' @param lambda regularization parameter
#' @param tau quantile parameter
#' @param step step-size
#' @param k order of differencing matrix
#' @export
spingarn_one_step <- function(theta, eta, y, D, cholM, lambda, tau = 0.05, step = 1, k = 3L) {
    invisible(.Call('_detrendr_spingarn_one_step', PACKAGE = 'detrendr', theta, eta, y, D, cholM, lambda, tau, step, k))
}

#'
#' Multiple steps of Spingarn's algorithm
#'
#' \code{spingarn_multi_step}
#' @param theta input 1
#' @param eta input 2
#' @param y response
#' @param D discrete differencing matrix
#' @param cholM cholesky of I + DtD
#' @param lambda regularization parameter
#' @param tau quantile parameter
#' @param step step-size
#' @param numberIter number of iterations
#' @param k order of differencing
#' @export
spingarn_multi_step <- function(theta, eta, y, D, cholM, lambda, tau = 0.05, step = 1, numberIter = 1, k = 3L) {
    .Call('_detrendr_spingarn_multi_step', PACKAGE = 'detrendr', theta, eta, y, D, cholM, lambda, tau, step, numberIter, k)
}

